Traceback (most recent call last):
  File "/home/codespace/.cache/pypoetry/virtualenvs/roi-power-flow-sample-aukJIi7B-py3.12/lib/python3.12/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/codespace/.cache/pypoetry/virtualenvs/roi-power-flow-sample-aukJIi7B-py3.12/lib/python3.12/site-packages/nbclient/client.py", line 1314, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/codespace/.cache/pypoetry/virtualenvs/roi-power-flow-sample-aukJIi7B-py3.12/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/python/3.12.1/lib/python3.12/asyncio/base_events.py", line 684, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/home/codespace/.cache/pypoetry/virtualenvs/roi-power-flow-sample-aukJIi7B-py3.12/lib/python3.12/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/home/codespace/.cache/pypoetry/virtualenvs/roi-power-flow-sample-aukJIi7B-py3.12/lib/python3.12/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/codespace/.cache/pypoetry/virtualenvs/roi-power-flow-sample-aukJIi7B-py3.12/lib/python3.12/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import numpy as np
import pandas as pd
import pandapower as pp
import plotly.graph_objects as go
import plotly.io as pio
from IPython.display import HTML, display


# Optional: Uncomment to disable numba warnings (or install numba in your poetry environment)
# pp.options.numba = False

PF_SETTINGS = {
    "algorithm": "nr",
    "max_iteration": 100,
    "tolerance_mva": 5e-3,
    "init": "dc",
    "enforce_q_lims": True,
    "calculate_voltage_angles": True,
    "logging": False,
    "voltage_depend_loads": False,
    "v_debug": True
}

# =============================================================================
# 1. Load or Create the pandapower Network
# =============================================================================
try:
    net = pp.from_pickle("adjusted_network_1162.p")
    print("Loaded adjusted_network_1162.p")
except Exception as e:
    print("Could not load 'adjusted_network_1162.p'. Creating a demo network. Error:", e)
    net = pp.create_empty_network()
    b1 = pp.create_bus(net, vn_kv=110, name="Bus A")
    b2 = pp.create_bus(net, vn_kv=110, name="Bus B")
    b3 = pp.create_bus(net, vn_kv=110, name="Bus C")
    pp.create_line(net, from_bus=b1, to_bus=b2, length_km=10, std_type="149-AL1/24-ST1A 110.0")
    pp.create_line(net, from_bus=b2, to_bus=b3, length_km=15, std_type="149-AL1/24-ST1A 110.0")

net.bus["in_service"] = True
net.line["in_service"] = True

pp.runpp(net, **PF_SETTINGS)
print("Load flow complete.")

# =============================================================================
# 2. Bus Filtering (Using Original Script Logic)
# =============================================================================
if "geodata" in net.bus.columns:
    filtered_buses = net.bus[
        (net.bus["vn_kv"] >= 110) &
        (net.bus["in_service"] == True) &
        (net.bus["x1"] > 0) &
        (net.bus["y1"] > 0)
    ].copy()
    filtered_buses["x1"] = filtered_buses["x1"]
    filtered_buses["y1"] = filtered_buses["y1"]
else:
    filtered_buses = net.bus[(net.bus["vn_kv"] >= 110) & (net.bus["in_service"] == True)].copy()
    np.random.seed(42)
    filtered_buses["x1"] = np.random.uniform(0, 100, size=len(filtered_buses))
    filtered_buses["y1"] = np.random.uniform(0, 100, size=len(filtered_buses))

# Create a DataFrame similar to the original "relevant_bus"
relevant_bus = pd.DataFrame({
    "index": filtered_buses.index,
    "x1": filtered_buses["x1"],
    "y1": filtered_buses["y1"],
    "bus_names": filtered_buses["bus_names"]
})
bus_ids = relevant_bus["index"].tolist()

# =============================================================================
# 3. Line Filtering (Using Original Script Logic)
# =============================================================================
filtered_lines = net.line[net.line["in_service"] == True].copy()
filtered_lines = filtered_lines[
    filtered_lines["from_bus"].isin(bus_ids) & 
    filtered_lines["to_bus"].isin(bus_ids)
]

results = filtered_lines.copy()
results["loading_percent"] = net.res_line["loading_percent"]
results["p_from_mw"] = net.res_line["p_from_mw"]
results["name"] = results["name"].fillna("Unnamed Line")

# =============================================================================
# 4. Load Global Contingency Aggregator Data and Build Lookup
# =============================================================================
global_contingency_df = pd.read_csv("global_contingency_aggregator_June_Sept.csv")
def normalize_name(name):
    return " ".join(str(name).split()).strip().lower()

cont_map = {}
for i, row_c in global_contingency_df.iterrows():
    bname = normalize_name(row_c["Branch_Name"])
    med_post_flow = row_c["Median_Post_Contingency_Flow_Percent"]
    max_post_flow = row_c["Max_Post_Contingency_Flow_Percent"]
    worst_outage = row_c["Worst_Case_Outage_For_Max"]
    cont_map[bname] = (med_post_flow,max_post_flow, worst_outage)
default_cont_data = ("N/A", "No data", "No data")

# =============================================================================
# 5. Load Bus Aggregator Data from bus_lodf_aggregator_June_Sept.csv
# =============================================================================
try:
    bus_lodf_df = pd.read_csv("bus_lodf_aggregator_June_Sept.csv")
    def normalize_bus_name(name):
        return " ".join(str(name).split()).lower()
    bus_lodf_df["Normalized_Bus_Name"] = bus_lodf_df["Bus_Name"].apply(normalize_bus_name)
    
    best_list = []
    for idx, row in relevant_bus.iterrows():
        bus_name = row["bus_names"]
        norm_bus_name = normalize_bus_name(bus_name)
        match = bus_lodf_df[bus_lodf_df["Normalized_Bus_Name"] == norm_bus_name]
        if not match.empty:
            cumulative_otdf = match.iloc[0]["Cumulative_OTDF"]
            maximum_otdf = match.iloc[0]["Maximum_OTDF"]
            minimum_otdf = match.iloc[0]["Minimum_OTDF"]
            median_otdf = match.iloc[0]["Median_OTDF"]
            worst_circuit_otdf = match.iloc[0]["Worst_Circuit"]
        else:
            cumulative_otdf = np.nan
            maximum_otdf = np.nan
            minimum_otdf = np.nan
            median_otdf = np.nan
            worst_circuit_otdf = np.nan
        best_list.append({
            "Bus_ID": row["index"],
            "cumulative_otdf": cumulative_otdf,
            "maximum_otdf": maximum_otdf,
            "minimum_otdf": minimum_otdf,
            "median_otdf": median_otdf,
            "worst_circuit_otdf": worst_circuit_otdf,
        })
    best_results_full_discharge = pd.DataFrame(best_list)
    print("Loaded bus-level aggregator data.")
except Exception as e:
    print("Error loading bus_lodf_aggregator_June_Sept.csv, using dummy data:", e)
    best_results_full_discharge = pd.DataFrame({
        "Bus_ID": relevant_bus["index"],
        "cumulative_otdf": 0,
        "maximum_otdf": 0,
        "minimum_otdf": 0,
        "median_otdf": 0,
        "worst_circuit_otdf": 0,
    })

contingency_trigger = True

# =============================================================================
# 6. Plotting Function (plot_network)
# =============================================================================
def plot_network(relevant_bus, results, bus_ids, best_results_full_discharge, cont_map, contingency_trigger=True):
    fig = go.Figure()
    
    # Build nodal aggregated dictionary.
    best_results_discharge_dict = {}
    for i, row in best_results_full_discharge.iterrows():
        bus_id = row["Bus_ID"]
        best_results_discharge_dict[bus_id] = (row["cumulative_otdf"], row["maximum_otdf"], row["minimum_otdf"], row["median_otdf"], row["worst_circuit_otdf"])
    
    # Updated helper functions with NaN checks.
    def get_line_color(val, min_val=0, max_val=100):
        if pd.isna(val):
            return "rgba(128,128,128,1)"
        frac = np.interp(val, [min_val, max_val], [0, 1])
        red = int(255 * frac)
        blue = int(255 * (1 - frac))
        return f"rgba({red}, 0, {blue}, 1)"
    
    def get_node_color(val, min_val=0, max_val=100):
        if pd.isna(val):
            return "rgba(128,128,128,1)"
        frac = np.interp(val, [min_val, max_val], [0, 1])
        red = int(255 * frac)
        blue = int(255 * (1 - frac))
        return f"rgba({red}, 0, {blue}, 1)"
    
    # Build adjusted coordinates: key = bus ID, value = (x, y, bus name)
    adjusted_coords = {
        row["index"]: (float(row["x1"]), float(row["y1"]), row["bus_names"])
        for i, row in relevant_bus.iterrows() if pd.notna(row["x1"]) and pd.notna(row["y1"])
    }
    
    annotations = []
    traces = []
    
    # Plot buses.
    for bus_id, (x, y, bname) in adjusted_coords.items():
        ptdf_sum, lodf_pct, min_otdf, med_otdf,worst_circuit = best_results_discharge_dict.get(bus_id, ("N/A", "N/A"))
        default_color = "rgba(128,128,128,1)"
        node_color = default_color
        if isinstance(lodf_pct, (int, float)):
            node_color = get_node_color(lodf_pct)
        text_node = (f"Cumulative OTDF Sum: {ptdf_sum:.1f}%<br>"
                        f"Maximum OTDF: {lodf_pct:.1f}%<br>"
                        f"Minimum OTDF: {min_otdf:.1f}%<br>"
                        f"Median OTDF: {med_otdf:.1f}%<br>"
                        f"Worst Circuit: {worst_circuit}%<br>"
                    )
        traces.append(go.Scatter(
            x=[x], y=[y],
            mode="markers",
            text=[text_node],
            hoverinfo="text",
            marker=dict(size=10, color=default_color),
            name=f"Bus {bus_id}"
        ))
        annotations.append(dict(
            x=x, y=y, text=bname, showarrow=False,
            font=dict(size=10, color="#ffffff"), bgcolor=node_color, opacity=0.8
        ))
    
    # Plot lines.
    for _, r_row in results.iterrows():
        loading_percent = r_row["loading_percent"]
        if pd.isna(loading_percent) or loading_percent == 0:
            continue
        if (r_row["from_bus"] not in adjusted_coords) or (r_row["to_bus"] not in adjusted_coords):
            continue
        from_coords = adjusted_coords[r_row["from_bus"]]
        to_coords = adjusted_coords[r_row["to_bus"]]
        
        line_name = str(r_row["name"])
        norm_line_name = normalize_name(line_name)
        med_cont_loading, cont_loading, cause_name = cont_map.get(norm_line_name, default_cont_data) if contingency_trigger else ("N/A", "No data")
        line_color = get_line_color(loading_percent)
        
        traces.append(go.Scatter(
            x=[from_coords[0], to_coords[0]],
            y=[from_coords[1], to_coords[1]],
            mode="lines", line=dict(color=line_color, width=3),
            hoverinfo="none"
        ))
        mid_x = (from_coords[0] + to_coords[0]) / 2
        mid_y = (from_coords[1] + to_coords[1]) / 2
        
        text_line = (f"Line: {line_name}<br>"
                     f"Maximum Intact Loading: {loading_percent:.1f}%<br>"
                     f"Median Post-Contingency Loading: {med_cont_loading:.1f}%<br>"
                     f"Maximum Post-Contingency Loading: {cont_loading:.1f}%<br>"
                     f"Worst Contingency Cause Element: {cause_name}")
        traces.append(go.Scatter(
            x=[mid_x], y=[mid_y],
            mode="markers", marker=dict(size=5, color=line_color),
            text=[text_line], hoverinfo="text"
        ))
        
        if r_row["p_from_mw"] >= 0:
            arrow_coords = (to_coords[0], to_coords[1], from_coords[0], from_coords[1])
        else:
            arrow_coords = (from_coords[0], from_coords[1], to_coords[0], to_coords[1])
        annotations.append(dict(
            x=mid_x, y=mid_y,
            ax=arrow_coords[2], ay=arrow_coords[3],
            xref="x", yref="y", axref="x", ayref="y",
            showarrow=True, arrowhead=2, arrowsize=1, arrowwidth=2, arrowcolor=line_color
        ))
    
    fig.add_traces(traces)
    fig.update_layout(
        annotations=annotations,
        title="Network Diagram with Post-Contingency Results",
        showlegend=False,
        width=1000,
        height=800,
        yaxis=dict(autorange="reversed")
    )
    #fig.show()
    return fig

# =============================================================================
# 7. Call the Plot Function
# =============================================================================
fig = plot_network(
    relevant_bus=relevant_bus,
    results=results,
    bus_ids=bus_ids,
    best_results_full_discharge=best_results_full_discharge,
    cont_map=cont_map,
    contingency_trigger=True
)

# Convert the figure to an HTML snippet.
fig_html = fig.to_html(include_plotlyjs="cdn", full_html=False)

# Embed it in the notebook.
from IPython.display import HTML, display
display(HTML(fig_html))


------------------

----- stdout -----
Loaded adjusted_network_1162.p
----- stdout -----
Load flow complete.
----- stdout -----
Loaded bus-level aggregator data.
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mValueError[0m                                Traceback (most recent call last)
Cell [0;32mIn[3], line 276[0m
[1;32m    271[0m     [38;5;28;01mreturn[39;00m fig
[1;32m    273[0m [38;5;66;03m# =============================================================================[39;00m
[1;32m    274[0m [38;5;66;03m# 7. Call the Plot Function[39;00m
[1;32m    275[0m [38;5;66;03m# =============================================================================[39;00m
[0;32m--> 276[0m fig [38;5;241m=[39m [43mplot_network[49m[43m([49m
[1;32m    277[0m [43m    [49m[43mrelevant_bus[49m[38;5;241;43m=[39;49m[43mrelevant_bus[49m[43m,[49m
[1;32m    278[0m [43m    [49m[43mresults[49m[38;5;241;43m=[39;49m[43mresults[49m[43m,[49m
[1;32m    279[0m [43m    [49m[43mbus_ids[49m[38;5;241;43m=[39;49m[43mbus_ids[49m[43m,[49m
[1;32m    280[0m [43m    [49m[43mbest_results_full_discharge[49m[38;5;241;43m=[39;49m[43mbest_results_full_discharge[49m[43m,[49m
[1;32m    281[0m [43m    [49m[43mcont_map[49m[38;5;241;43m=[39;49m[43mcont_map[49m[43m,[49m
[1;32m    282[0m [43m    [49m[43mcontingency_trigger[49m[38;5;241;43m=[39;49m[38;5;28;43;01mTrue[39;49;00m
[1;32m    283[0m [43m)[49m
[1;32m    285[0m [38;5;66;03m# Convert the figure to an HTML snippet.[39;00m
[1;32m    286[0m fig_html [38;5;241m=[39m fig[38;5;241m.[39mto_html(include_plotlyjs[38;5;241m=[39m[38;5;124m"[39m[38;5;124mcdn[39m[38;5;124m"[39m, full_html[38;5;241m=[39m[38;5;28;01mFalse[39;00m)

Cell [0;32mIn[3], line 241[0m, in [0;36mplot_network[0;34m(relevant_bus, results, bus_ids, best_results_full_discharge, cont_map, contingency_trigger)[0m
[1;32m    236[0m mid_x [38;5;241m=[39m (from_coords[[38;5;241m0[39m] [38;5;241m+[39m to_coords[[38;5;241m0[39m]) [38;5;241m/[39m [38;5;241m2[39m
[1;32m    237[0m mid_y [38;5;241m=[39m (from_coords[[38;5;241m1[39m] [38;5;241m+[39m to_coords[[38;5;241m1[39m]) [38;5;241m/[39m [38;5;241m2[39m
[1;32m    239[0m text_line [38;5;241m=[39m ([38;5;124mf[39m[38;5;124m"[39m[38;5;124mLine: [39m[38;5;132;01m{[39;00mline_name[38;5;132;01m}[39;00m[38;5;124m<br>[39m[38;5;124m"[39m
[1;32m    240[0m              [38;5;124mf[39m[38;5;124m"[39m[38;5;124mMaximum Intact Loading: [39m[38;5;132;01m{[39;00mloading_percent[38;5;132;01m:[39;00m[38;5;124m.1f[39m[38;5;132;01m}[39;00m[38;5;124m%<br>[39m[38;5;124m"[39m
[0;32m--> 241[0m              [38;5;124mf[39m[38;5;124m"[39m[38;5;124mMedian Post-Contingency Loading: [39m[38;5;132;43;01m{[39;49;00m[43mmed_cont_loading[49m[38;5;132;43;01m:[39;49;00m[38;5;124;43m.1f[39;49m[38;5;132;43;01m}[39;49;00m[38;5;124m%<br>[39m[38;5;124m"[39m
[1;32m    242[0m              [38;5;124mf[39m[38;5;124m"[39m[38;5;124mMaximum Post-Contingency Loading: [39m[38;5;132;01m{[39;00mcont_loading[38;5;132;01m:[39;00m[38;5;124m.1f[39m[38;5;132;01m}[39;00m[38;5;124m%<br>[39m[38;5;124m"[39m
[1;32m    243[0m              [38;5;124mf[39m[38;5;124m"[39m[38;5;124mWorst Contingency Cause Element: [39m[38;5;132;01m{[39;00mcause_name[38;5;132;01m}[39;00m[38;5;124m"[39m)
[1;32m    244[0m traces[38;5;241m.[39mappend(go[38;5;241m.[39mScatter(
[1;32m    245[0m     x[38;5;241m=[39m[mid_x], y[38;5;241m=[39m[mid_y],
[1;32m    246[0m     mode[38;5;241m=[39m[38;5;124m"[39m[38;5;124mmarkers[39m[38;5;124m"[39m, marker[38;5;241m=[39m[38;5;28mdict[39m(size[38;5;241m=[39m[38;5;241m5[39m, color[38;5;241m=[39mline_color),
[1;32m    247[0m     text[38;5;241m=[39m[text_line], hoverinfo[38;5;241m=[39m[38;5;124m"[39m[38;5;124mtext[39m[38;5;124m"[39m
[1;32m    248[0m ))
[1;32m    250[0m [38;5;28;01mif[39;00m r_row[[38;5;124m"[39m[38;5;124mp_from_mw[39m[38;5;124m"[39m] [38;5;241m>[39m[38;5;241m=[39m [38;5;241m0[39m:

[0;31mValueError[0m: Unknown format code 'f' for object of type 'str'

